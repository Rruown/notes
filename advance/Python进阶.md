# NumPy

## 资料

[NumPy中文官网参考手册](https://www.numpy.org.cn/reference/)

## 多维数组ndarray

### Shape

表示数组维度的元组。

**`shape(12,)`****与****`shape(12,1)`****的区别：**

**`shape(12,)`****代表索引只有一个，相当于普通数组，而****`shape(12,1)`****的索引有两个，是一个二维数组**

```Python
# 访问shape(12,)的数组
x[0]

# 访问shape(1,12)的数组
x[0,0]
```

### 切片和索引

numpy切片是python切片的扩展

-   索引的切片语义`i:j:k`，其中$i$是起始索引，$j$是结束索引（前闭后开区间），$k $是步数
    
-   多维数组有N个索引，用`,`分别表示每个索引的切片
    
    ```Python
    # x shape is (2, 3, 1)，也就是有3个索引
    x = np.array([[[1],[2],[3]], [[4],[5],[6]]])
    
    # 第一个索引切片从1开始，到2结束
    # 第二个索引切片从0开始，到2结束
    # 第三个索引切片从0开始，到1结束
    y = x[1:, :2, :]
    ```
    
-   `...`可以用于省略多个`:`
    

```Python
# x shape is (2, 3, 1)，也就是有3个索引
x = np.array([[[1],[2],[3]], [[4],[5],[6]]])

# 等价于 y = x[1:, :, :]
y = x[1:, ...]

# 等价于 y = x[:, :, 1:]
y = x[..., 1:]
```

### 广播机制

**element-wise**操作：指两个Tensor对应元素的操作，对应关系以索引的方式给出。常见的**element-wise**操作有矩阵加减乘除等。

**对于不同shape的element-wise操作，广播机制以简洁高效的方式执行计算。**

**广播机制的规则如下：**

1.  如果两个数组不具有相同的阶（也就是维度的数量，或者是数组索引的数量），则将较低阶数组的形状添加1，直到两个形状具有相同的长度。
    
2.  如果两个数组在维度上具有相同的大小，或者如果其中一个数组在该维度中的大小为1，则称这两个数组在维度上是兼容的。
    
3.  如果数组在所有维度上兼容，则可以一起广播。
    
4.  广播之后，每个数组的形状就好像等于两个输入数组的所有维度上的最大值。
    
5.  在一个数组的大小为1且另一个数组的大小大于1的任何维度中，第一个数组的行为就像沿着该维度复制一样
    

### 数组方法

ndarray的算数运算都是element-wise操作。

线性代数接口如`mulmat`函数指矩阵乘法，不要与`*`运算搞混

#### 项目操作与选择

##### numpy.repeat

`numpy.repeat(a, repeats, axis=None)`

-   a：数组
    
-   repeats：元素的重复次数
    
-   axis：指定的坐标轴
    

```Python
b = np.repeat(a, 2, axis=1)

print(b)
# [[0.7166098  0.7166098  0.91493356 0.91493356 0.6440768  0.6440768 ]
# [0.42674658 0.42674658 0.52309262 0.52309262 0.23595525 0.23595525]
# [0.6252462  0.6252462  0.75036285 0.75036285 0.85969274 0.85969274]
# [0.94043681 0.94043681 0.12059285 0.12059285 0.41142573 0.41142573]]

print(a)
# [[0.7166098  0.91493356 0.6440768 ]
# [0.42674658 0.52309262 0.23595525]
# [0.6252462  0.75036285 0.85969274]
# [0.94043681 0.12059285 0.41142573]]
```

#### 搜索与排序

##### numpy.where

`numpy.where(`_**`condition`**_**`, [`**_**`x`**_**`,`** _**`y`**_**`, ]`**_**`/`**_**`)`**

-   _condition_： 布尔类型的数组
    
      `True`时选择`x`，`False`时选择`y`
    

当只给出_condition_时，`numpy.where`函数的功能就等于`np.asarray(condition).nonzero()`

_**即给出condition的非零元素索引（每个索引一个数组）**_

-   _x,y_：数组
    

例子如下：a是一个2维数组，where函数返回非0元素的索引数组。

array([0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3])是第一个索引的数组

array([0, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2])是第二个索引

(0, 0) (0, 2) (1, 1) (1, 2) (1, 3)...是a非零元素的索引

```Python
print(a)
# [[1 0 1]
# [1 1 1]
# [1 1 1]
# [1 1 1]]

print(np.where(a))
# (array([0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3], dtype=int32), array([0, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2], dtype=int32))
```

#### 组合数组

##### numpy.stack

沿着新轴堆叠数组

**`numpy.stack(`**_**`arrays`**_**`,`** _**`axis=0`**_**`,`** _**`out=None`**_**`,`** _**`*`**_**`,`** _**`dtype=None`**_**`,`** _**`casting='same_kind'`**_**`)`**

-   _**`arrays`**__**：数组序列**_
    

shape必须相同