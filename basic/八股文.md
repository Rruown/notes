# MySQL

## 基本概念

### 1. 数据库的三大范式

**第一范式：** 表中的所有字段都是原子的。不可以将多个值存在一个字段中
**第二范式：** 非主键字段必须完全依赖于主键。如`用户信息表(用户ID，用户名，城市，...)`城市与用户ID无关，可以将城市移动到其他表中。
**第三范式：** 非主键字段必须直接依赖于主键，不能存在传递依赖。如`用户信息表(用户ID，用户名，年龄，出生日期，...)`，年龄可以通过出生日期计算得出，所以年龄也依赖于出生日期，而不是直接依赖于用户ID。

### 2. 关系型数据库和非关系型数据库的优缺点对比，及应用场景

**数据结构：** 关系型数据库的数据结构是表格形式，数据以行列的形式存储，；非关系型数据库的数据结构是文档形式，数据以键值对的形式存储

**扩展性:**  非关系型数据库具有很好的可扩展性，可以通过添加更多的节点来实现扩展，这样可以轻松地处理大量的数据。相比之下，关系型数据库的扩展性较差，需要在单个服务器上增加处理能力或者增加更多的服务器，这需要更多的资源和时间。

**事务性能:**  关系型数据库具有很好的事务性能，支持ACID事务，保证数据的一致性和可靠性。相比之下，非关系型数据库不支持完全的ACID事务，但是可以通过分布式事务来实现数据的一致性。

**数据查询:**  关系型数据库具有很好的数据查询能力，可以使用SQL语言进行复杂的查询操作。相比之下，非关系型数据库的查询语言较为简单，不支持复杂的查询操作。

**数据存储：** 关系型数据库可以保证数据的完整性和一致性，但是存储空间较大。相比之下，非关系型数据库的存储空间较小，但是可能会出现数据的不一致性。

关系型数据库：适合处理需要严格数据一致性和事务性能的应用程序，例如财务和交易系统。
非关系型数据库：适合处理大量的非结构化和半结构化数据，例如社交网络和日志系统。同时，在一些需要快速读写的场景中，非关系型数据库的性能优势更为明显。

## 基础架构

### 一条select语句是如何执行的

**第一步，你会先连接到这个数据库上，这时候负责的就是连接器**。连接器负责跟客户端建立连接、获取权限、维持和管理连接 。建立连接的命令：`mysql -h$ip -P$port -u$user -p `。

连接器通过用户名和密码认证身份，身份认证通过后，连接器会到权限表里面查出拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 

连接器还负责维持和管理连接。对于空闲连接使用`show processlist`命令查看连接状态，如果客户端如果太长时间没动静，连接器就会自动将它断开。 

**第二步是查询缓存**。之前执行过的语句和结果可能会以`key-value`对的形式缓存。`key`是查询的语句，`value`是查询的结果。如果查询能够直接在这个缓存中找到`key`，那么这个`value`就会被直接返回给客户端。 但是只要有更新操作，查询缓存中的所有缓存都会失效。 

**第三步是分析器**。分析器先会做词法分析，MySQL需要识别出输入的SQL语句里面分别是什么，代表什么。 然后做语法分析，根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。 

**第四步是优化器**。经过分析器，MySQL就知道要做什么了。但是在开始之前，还需要经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。 

**最后一步是执行器**。MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。首先会判断用户有没有表T的查询权限，如果没有就返回权限错误。有的话就打开表继续执行。

对于没有索引的情况下： 
1.  调用InnoDB引擎接口“取表的第一行”，判断条件是否满足，如果不满足则跳过，如果满足则将这行存在结果集中； 
2.  调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 
3.  执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

对于有索引的情况下： 
1.  调用InnoDB引擎接口“取满足条件的第一行”，将这行存在结果集中；  
2.  调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 
3.  执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

### 一条update语句是如何执行的

**执行器和InnoDB引擎在执行简单的update语句时的内部流程：**
1.  执行器调用存储引擎的“取数据”接口：引擎会先使用索引找到这行，如果这一行数据所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 
2.  执行器拿到引擎给的行数据，再调用引擎接口写入新数据。 
3.  引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。 
4.  执行器生成这个操作的binlog，并把binlog写入磁盘。 
5.  执行器调用引擎的提交事务接口。引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。 

**为什么需要两阶段提交?** 
1.  先写redo log后写binlog：redo log写完后，即使奔溃也可以恢复，所以数据库会有`x'`。但是binlog是没有的。 
2.  先写binlog后写redo log：binlog写完后，突然奔溃是无法恢复的，所有数据库中没有`x'`的记录，但是binlog有。

## 索引篇

### #性能优化

#### 1. 覆盖索引
**索引“覆盖了”查询需求，称为覆盖索引**
覆盖索引可以减少回表次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

#### 2. 最左前缀原则
**减少维护索引的数量**
只要满足索引的最左前缀，就可以利用索引加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符

#### 3. 索引下推
**减少回表次数**
可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

#### 4. 选择**唯一索引**还是**普通索引**？

**`change buffer`主要节省随机读磁盘的IO消耗**
**数据更新过程：** 如果数据页在内存中，就直接更新；否则就将更新操作缓存在`change buffer`中。
**插入缓存的merge：** 将`change buffer`中的操作应用到原数据页，得到最新结果的过程称为merge
1. 在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作
2. 系统有后台线程会定期merge
3. 数据库正常关闭（shutdown）的过程中，也会执行merge操作。

`change buffer`的优点在于减少了磁盘读取数据页的次数，语句的执行速度会得到明显的提升

对于查询过程：
- 普通索引找到满足条件第一条记录后，需要继续遍历直到不满足为止。
- 唯一索引找到满足条件的一条记录即可。

对于更新过程，假设记录不在内存中：
- 普通索引将更新记录在change buffer；
- 唯一索引需要将数据页读入内存，判断有没有冲突，插入这个值；

#### 5. 如何避免索引失效

- 避免不符合最左前缀原则
- 避免**对索引列进行函数计算或隐式转换**
- 避免查询条件使用`or`连接，`or`的两边不全是索引列
- 注意**优化器可能错误选择了索引**
- 避免使用左模糊匹配


#### 6. 哪一种的`count`性能最好？


### 事务篇

#### 1. 事务的特性

**原子性：** 事务的操作是不可分割的，要么都成功完成，要么都不执行
**隔离性：** 事务有独立的数据空间，并发事务之间相互隔离互相不影响。由多版本并发控制与锁实现
**持久性：** 事务提交后，数据库突然发生奔溃，也可以通过手段恢复

#### 2. 并发事务引起的问题？

**脏读：** 事务执行过程中读取到了未提交的数据
**不可重复读：** 事务执行过程中前后两次读取同一数据，出现不一致的情况
**幻读：** 事务执行过程中，前后两次读取同一范围，出现不一致的情况，尤其指新插入的行

#### 3. 事务的隔离级别
1. 读未提交
2. 读提交
3. 可重复度
4. 串行化

#### 4. 多版本并发控制

数据表中的一行记录，可能有多个版本(row)，每个版本有自己的`row trx_id`。每次事务更新数据的时候，都会把`事务ID`赋值给这个数据作为新版本，并将旧版本写入到`undo`日志中，以链表的形式，形成版本链。

一致性试图创建时，维护活跃的事务ID集合。数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。
对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：
1.  如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2.  如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3.  如果落在黄色部分，那就包括两种情况  
	-  若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；  
	- 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。
