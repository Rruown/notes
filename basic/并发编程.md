# 并发编程

## 并发编程的源头问题

### 可见性

一个线程对共享变量的修改，另一个线程能够立刻“看到”，称为**可见性**。

**缓存导致的可见性问题**
每个CPU都有自己的缓存，多个线程在不同的CPU上执行，操作都在不同的缓存上。缓存数据写回内存时，会造成不可预知的结果。

### 原子性

**原子性**指一条指令无法被中断。

**进程切换导致的原子性问题**
一个高级语言的语句比如`count++`需要至少三条CPU指令：

- 1、将count变量从内存加载到寄存器
- 2、在寄存中加一
- 3、将结果写回内存

在多线程情况下，高级语言的一条语句的执行**不再是原子的**，线程的切换会导致不可预知的结果。

### 有序性

编译器为了优化性能，会调整指令的执行顺序。

```java
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          instance = new Singleton();
        }
    }
    return instance;
  }
}
```

正常认为`new`操作：

- 申请一个内存空间
- 初始化对象
- 将地址赋值给`instance`

实际被编译器优化后的`new`操作：

- 申请一个内存空间
- 将地址赋值给`instance`
- 初始化对象

当线程1执行到`new`操作的第二步时发生线程切换，线程2的入口判断为false，将返回一个未初始化的对象。